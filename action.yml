name: text-forge
description: Build/publish a Markdown chapter collection into multiple formats (MkDocs site, EPUB, combined markdown)

inputs:
  mkdocs_config:
    description: Path to mkdocs.yml
    required: false
    default: mkdocs.yml
  docs_dir:
    description: MkDocs docs_dir (where markdown lives)
    required: false
    default: text/ru
  site_dir:
    description: Output directory for MkDocs site
    required: false
    default: public/ru
  build_dir:
    description: Build artifacts directory
    required: false
    default: build
  strict:
    description: Run mkdocs build with --strict
    required: false
    default: 'true'
  copy_artifacts_into_docs:
    description: Copy EPUB + combined markdown into docs_dir/assets before mkdocs build
    required: false
    default: 'true'
  cover_image:
    description: Optional cover image path (relative to content repo)
    required: false
    default: ''
  create_root_redirect:
    description: Create public/index.html redirecting to /ru/
    required: false
    default: 'true'
  redirect_target:
    description: Redirect target for public/index.html
    required: false
    default: /ru/
  ensure_full_git_history:
    description: Fetch full git history if checkout is shallow (improves revision date accuracy)
    required: false
    default: 'true'
  use_github_token_for_committers:
    description: Export github.token as MKDOCS_GIT_COMMITTERS_APIKEY for mkdocs-git-committers-plugin-2
    required: false
    default: 'true'
  committers_token:
    description: Optional token to use for mkdocs-git-committers-plugin-2 (overrides github.token)
    required: false
    default: ''

outputs:
  combined_md:
    description: Path to combined markdown output
    value: ${{ steps.paths.outputs.combined_md }}
  pandoc_md:
    description: Path to pandoc-normalized markdown output
    value: ${{ steps.paths.outputs.pandoc_md }}
  epub:
    description: Path to generated EPUB
    value: ${{ steps.paths.outputs.epub }}

runs:
  using: composite
  steps:
    - id: paths
      shell: bash
      run: |
        set -euo pipefail
        echo "combined_md=${{ inputs.build_dir }}/text_combined.txt" >> "$GITHUB_OUTPUT"
        echo "pandoc_md=${{ inputs.build_dir }}/pandoc.md" >> "$GITHUB_OUTPUT"
        echo "epub=${{ inputs.build_dir }}/text_book.epub" >> "$GITHUB_OUTPUT"

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install Python deps (MkDocs + PyYAML)
      shell: bash
      run: |
        set -euo pipefail
        python -m pip install --upgrade pip
        python -m pip install \
          mkdocs==1.6.1 \
          mkdocs-material==9.6.22 \
          mkdocs-git-committers-plugin-2==2.5.0 \
          mkdocs-git-revision-date-localized-plugin==1.5.0 \
          pyyaml==6.0.3 \
          click==8.1.7 \
          livereload==2.7.1

    - name: Set up Pandoc
      uses: r-lib/actions/setup-pandoc@v2

    - name: Provide MkDocs hook (if missing)
      shell: bash
      run: |
        set -euo pipefail
        # Content repos reference shared hooks/overrides via paths like:
        #   hooks: [text-forge/mkdocs/hooks/nobr_emoticons.py]
        #   theme.custom_dir: text-forge/mkdocs/overrides
        # This step makes builds work even without a git submodule checkout.

        mkdir -p text-forge/mkdocs/hooks text-forge/mkdocs/overrides/partials

        # Hook
        if [ -f "${{ github.action_path }}/mkdocs/hooks/nobr_emoticons.py" ]; then
          cp -f "${{ github.action_path }}/mkdocs/hooks/nobr_emoticons.py" "text-forge/mkdocs/hooks/nobr_emoticons.py"
        fi

        # Theme overrides
        if [ -f "${{ github.action_path }}/mkdocs/overrides/partials/comments.html" ]; then
          cp -f "${{ github.action_path }}/mkdocs/overrides/partials/comments.html" "text-forge/mkdocs/overrides/partials/comments.html"
        fi
        if [ -f "${{ github.action_path }}/mkdocs/overrides/partials/source-file.html" ]; then
          cp -f "${{ github.action_path }}/mkdocs/overrides/partials/source-file.html" "text-forge/mkdocs/overrides/partials/source-file.html"
        fi

    - name: Stage 1 - Combine markdown from mkdocs.yml
      shell: bash
      run: |
        set -euo pipefail
        mkdir -p "${{ inputs.build_dir }}"
        python "${{ github.action_path }}/scripts/mkdocs-combine.py" "${{ inputs.mkdocs_config }}" > "${{ inputs.build_dir }}/text_combined.txt"

    - name: Stage 2 - Convert PyMdown blocks to Pandoc markdown
      shell: bash
      run: |
        set -euo pipefail
        pandoc -f markdown+smart "${{ inputs.build_dir }}/text_combined.txt" \
          --lua-filter="${{ github.action_path }}/scripts/pymdown-pandoc.lua" \
          --wrap=preserve \
          -t markdown \
          -o "${{ inputs.build_dir }}/pandoc.md"

    - name: Process EPUB metadata placeholders
      shell: bash
      run: |
        set -euo pipefail
        mkdir -p "${{ inputs.build_dir }}"

        GIT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.1.0")

        # Prefer a stable YYYY-MM-DD from git; fall back to current UTC date if unavailable.
        GIT_DATE=$(git log -1 --format=%cs 2>/dev/null || true)
        if [ -z "$GIT_DATE" ]; then
          GIT_DATE=$(date -u +%Y-%m-%d)
        fi

        GIT_DATE_DISPLAY=$(echo "$GIT_DATE" | python - <<'PY'
        import sys, datetime
        s = sys.stdin.read().strip()
        if not s:
          print('')
          raise SystemExit(0)
        months = {
          'January': 'января', 'February': 'февраля', 'March': 'марта', 'April': 'апреля',
          'May': 'мая', 'June': 'июня', 'July': 'июля', 'August': 'августа',
          'September': 'сентября', 'October': 'октября', 'November': 'ноября', 'December': 'декабря'
        }
        d = datetime.datetime.strptime(s, '%Y-%m-%d')
        out = d.strftime('%d %B %Y')
        for en, ru in months.items():
          out = out.replace(en, ru)
        print(out)
        PY
        )

        EDITION="$GIT_TAG, $GIT_DATE_DISPLAY"

        python - <<'PY'
        import os
        import re
        from pathlib import Path

        import yaml

        class _IgnoreUnknownTagsLoader(yaml.SafeLoader):
          pass

        def _unknown(loader, tag_suffix, node):
          # Handle mkdocs.yml custom tags like !ENV by returning the underlying scalar/sequence.
          if isinstance(node, yaml.ScalarNode):
            return loader.construct_scalar(node)
          if isinstance(node, yaml.SequenceNode):
            return loader.construct_sequence(node)
          if isinstance(node, yaml.MappingNode):
            return loader.construct_mapping(node)
          return None

        _IgnoreUnknownTagsLoader.add_multi_constructor('!', _unknown)

        mkdocs_path = Path(os.environ['MKDOCS_CONFIG'])
        meta_template_path = Path(os.environ['META_TEMPLATE'])
        out_path = Path(os.environ['META_OUT'])
        edition = os.environ['EDITION']
        date_iso = os.environ['DATE_ISO']

        mk = {}
        if mkdocs_path.exists():
          mk = yaml.load(mkdocs_path.read_text(encoding='utf-8'), Loader=_IgnoreUnknownTagsLoader) or {}

        def env(name: str, default: str) -> str:
          v = os.environ.get(name, '').strip()
          return v if v else default

        site_name = str(mk.get('site_name', '') or '').strip()
        site_desc = str(mk.get('site_description', '') or '').strip()
        site_author = str(mk.get('site_author', '') or '').strip()
        site_url = str(mk.get('site_url', '') or '').strip()
        copyright_ = str(mk.get('copyright', '') or '').strip()

        extra = mk.get('extra') or {}
        epub = (extra.get('epub') or {}) if isinstance(extra, dict) else {}
        epub_title = str(epub.get('title', '') or '').strip()
        epub_subtitle = str(epub.get('subtitle', '') or '').strip()
        epub_author = str(epub.get('author', '') or '').strip()
        epub_identifier = str(epub.get('identifier', '') or '').strip()
        epub_publisher = str(epub.get('publisher', '') or '').strip()
        epub_rights = str(epub.get('rights', '') or '').strip()

        title = env('EPUB_TITLE', epub_title or site_name or 'Book')
        subtitle = env('EPUB_SUBTITLE', epub_subtitle or site_desc)
        author = env('EPUB_AUTHOR', epub_author or site_author)
        identifier = env('EPUB_IDENTIFIER', epub_identifier or site_url or 'urn:book')
        publisher = env('EPUB_PUBLISHER', epub_publisher or site_author or 'Publisher')

        default_rights = (
          epub_rights
          or (copyright_ if copyright_ else (f"<a href=\"{site_url}\">{site_url}\</a>" if site_url else ''))
        )
        rights = env('EPUB_RIGHTS', default_rights)

        text = meta_template_path.read_text(encoding='utf-8')
        replacements = {
          '[title]': title,
          '[subtitle]': subtitle,
          '[author]': author,
          '[identifier]': identifier,
          '[publisher]': publisher,
          '[rights]': rights,
          '[edition]': edition,
          '[date]': date_iso,
        }

        for k, v in replacements.items():
          text = text.replace(k, v)

        # Sanity: avoid leaving placeholders behind (helps catch template drift).
        leftovers = sorted(set(re.findall(r'\[[a-z_]+\]', text)))
        if leftovers:
          raise SystemExit(f"Unreplaced placeholders in book_meta: {', '.join(leftovers)}")

        out_path.write_text(text, encoding='utf-8')
        PY
        EDITION="$EDITION" \
        DATE_ISO="$GIT_DATE" \
        MKDOCS_CONFIG="${{ inputs.mkdocs_config }}" \
        META_TEMPLATE="${{ github.action_path }}/epub/book_meta.yml" \
        META_OUT="${{ inputs.build_dir }}/book_meta_processed.yml"

    - name: Stage 3 - Generate EPUB
      shell: bash
      run: |
        set -euo pipefail
        if [ -n "${{ inputs.cover_image }}" ] && [ ! -f "${{ inputs.cover_image }}" ]; then
          echo "::warning::cover_image was set to '${{ inputs.cover_image }}' but file was not found; falling back to epub/cover.jpg if present, otherwise building without cover."
        fi
        COVER=""
        if [ -n "${{ inputs.cover_image }}" ] && [ -f "${{ inputs.cover_image }}" ]; then
          COVER="${{ inputs.cover_image }}"
        elif [ -f "epub/cover.jpg" ]; then
          COVER="epub/cover.jpg"
        fi
        COVER_ARG=""
        if [ -n "$COVER" ]; then
          COVER_ARG="--epub-cover-image=$COVER"
        fi
        pandoc -f markdown+smart "${{ inputs.build_dir }}/pandoc.md" \
          -o "${{ inputs.build_dir }}/text_book.epub" \
          --standalone \
          --toc \
          --toc-depth=2 \
          --metadata-file="${{ inputs.build_dir }}/book_meta_processed.yml" \
          --resource-path="${{ inputs.docs_dir }}" \
          --css="${{ github.action_path }}/epub/epub.css" \
          $COVER_ARG \
          -t epub3

    - name: Copy artifacts into docs assets
      if: ${{ inputs.copy_artifacts_into_docs == 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        mkdir -p "${{ inputs.docs_dir }}/assets"
        cp "${{ inputs.build_dir }}/text_book.epub" "${{ inputs.docs_dir }}/assets/" 
        cp "${{ inputs.build_dir }}/text_combined.txt" "${{ inputs.docs_dir }}/assets/"

    - name: Configure git-committers token
      shell: bash
      run: |
        set -euo pipefail
        if [ -n "${{ inputs.committers_token }}" ]; then
          echo "MKDOCS_GIT_COMMITTERS_APIKEY=${{ inputs.committers_token }}" >> "$GITHUB_ENV"
        elif [ "${{ inputs.use_github_token_for_committers }}" = "true" ]; then
          echo "MKDOCS_GIT_COMMITTERS_APIKEY=${{ github.token }}" >> "$GITHUB_ENV"
        fi

    - name: Ensure full git history
      if: ${{ inputs.ensure_full_git_history == 'true' }}
      shell: bash
      run: |
        set -euo pipefail

        IS_SHALLOW=$(git rev-parse --is-shallow-repository 2>/dev/null || echo false)
        if [ "$IS_SHALLOW" = "true" ]; then
          echo "Repository is shallow; fetching full history for accurate revision dates."
          git fetch --prune --unshallow --tags || true
        fi

    - name: Build MkDocs site
      shell: bash
      run: |
        set -euo pipefail
        STRICT=""
        if [ "${{ inputs.strict }}" = "true" ]; then
          STRICT="--strict"
        fi
        mkdocs build --config-file="${{ inputs.mkdocs_config }}" --site-dir="${{ inputs.site_dir }}" $STRICT

    - name: Create root redirect
      if: ${{ inputs.create_root_redirect == 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        PUBLIC_DIR=$(dirname "${{ inputs.site_dir }}")
        mkdir -p "$PUBLIC_DIR"
        cat > "$PUBLIC_DIR/index.html" <<HTML
        <!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="refresh" content="0; url=${{ inputs.redirect_target }}"><link rel="canonical" href="${{ inputs.redirect_target }}"><title>Redirecting to ${{ inputs.redirect_target }}</title></head><body><p>Redirecting to <a href="${{ inputs.redirect_target }}">${{ inputs.redirect_target }}</a>...</p><script>window.location.href="${{ inputs.redirect_target }}";</script></body></html>
        HTML
